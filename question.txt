mybatis 二级缓存，redis缓存
dubbo框架使用 dubbo zk 调用交互流程

springMVC springboot  springcloud 
基于redis缓存开发

springcloud 包含组件及相关组件提问
fegin了解，其它组件基本不清楚
dubbo不了解
restTemplate熟练使用
aop、filter、redis、mybatis、mysql、mysql索引创建使用、分布式锁等相关提问、http调用
分布式部署、微服务部署相关不了解
接口幂等性设计、mq消息可靠性设计相关提问
spring、springcloud、mybatis等源码、项目使用解答
redis数据类型、锁， mysql索引、分库分表等问题解答
springCloud微服务，技术栈使用、服务熔断、降级、异常提问
redis持久化、多线程、spring源码、bean线程安全、bean事务提问
微服务理解， springCloud、spring问题
mysql索引， 分库分表策略、技术实现
redis、mybatis相关
微服务优缺点， SpringCloud、Kafka等微服务组件，服务治理方案
redis持久化、数据类型、缓存穿透解决方案
Spring bean声明周期、线程安全、事务实现、分布式事务
mysql分表实现、索引类型、B树
spring 的aop和ioc，动态代理等


Eureka和zk的使用、优缺点，AP、CP、 集群问题及解决方案
SpringCloud组件使用， 协议、Dubbo协议
jvm内存分布，GC使用，参数优化， 方法区1.8调整
Spring加载源码解析、事务实现机制
ThreadLocal分析使用，内存泄漏原因及解决方案
java集合，HashMap内部实现，版本变化实现，扩容插入问题
分布式锁介绍及实现方式，分布式事务等

redis缓存更新的方式，数据不一致解决办法？
分别解释一下什么是缓存穿透、缓存击穿以及解决方案？
答：缓存穿透是缓存中没有，数据库中也没有。解决方案将请求key为键放入缓存，设置超时时间。避免暴力攻击。
    缓存击穿是缓存中没有，数据库中有，此时大量请求过来到数据库，库压力激增。解决方案，缓存预热，热点数据不设置过期时间。

redis持久化的方式以及区别？
答：AOF,RDB
      AOF是记录每次的写命令追加到文件尾部，默认每秒钟后台线程刷磁盘，会存在丢失最近1s的数据。文件过大的时候自动最小化命令集合重新文件。(appendonly.aof)
      RDB是数据快照，将某一时刻的数据存储到磁盘。持久化的过程是异步将快照写入临时文件，完成写入后替换原文件。（dump.rdb）

微服务当中数据一致性如何保证？
答： 时效性要求不高的，可以使用基于消息的最终一致性，rocketmq的事务消息，消费者端要保证接口的幂等，rocketmq会有重复消费的问题，rocketmq的消费模式是最少一次，如果消费端消费失败，会重新投递消息到broker。
       时效性要求高的，使用seata框架提供的AT或TCC，TCC会有空回滚，幂等，悬挂等问题。

Dubbo 核心的配置有哪些
答：registry，service，protocol，reference，application

Dubbo有哪几种负载均衡策略，默认是哪种？
答：failover默认方式失败自动切换
       failfast快速失败
       failsafe安全失败
       failback失败后后台线程重试

实际项目中如何实现会话共享，有什么解决方案，以及有什么区别
答：服务节点复制tomcat使用该方案，集中存储redis

JVM内存模型以及垃圾回收过程？简单介绍知道的几种垃圾回收算法？
答：堆，栈，方法区，本地方法区

谈一下HashMap中hash函数是怎么实现的？为什么不直接将key作为哈希值而是与高16位做异或运算？ 
答：算法  (n-1)&(h ^ (h >>> 16)) 
       右移16位，做异或运算，及保留了高16位，用高16位与低16位做异或运算（保留了高16位hashcode的特征，因为int是4字节，及高16位是0
       在做与运算的时候，原hashcod的高16位就没有作用了）
       直接运算，高16位的hashcode特征就没有了。这样降低了冲突的概率。
缓存如何保持同步？
答：数据双写的时候，先删除缓存记录，让读请求重置缓存中数据。在写操作发生的同时，如果有读请求过来，串行化读写请求，
      将读写请求放入先进先出队列，避免写请求还没提交，读请求获取了脏数据写入了缓存。还可以在优化，例如都是查看上个请求是否是都请求
      进行请求合并。减少逻辑。
      
针对缓存击穿、雪崩、穿透的应对方案
答：雪崩是大量的key同一时间过期了，在设置key过期时尽量离散写。
jvm发生fullGc问题排查


hashmap的哈希函数是怎么设计的？为什么要这样设计？为什么采用hashcode的高16位和低16位异或能降低hash碰撞？hash函数能不能直接用key的hashcode？
答：（n-1）&(hashcode^hashcode>>>16) 数组大小是一个int类型的正整数，及高16位都是0，如果直接做与运算，那么hashcode的高16位的值就不起作用
    。所以获取key的hashcode，然后右移16位，做异或运算，这样就是hashcode的高16为与自己的低16位做了一个异或运算。这样hashcode的高16位也参与了
    计算。
数据【1-9】分组，然后根据输入的数据，获取所在的对应的组？

多线程方式实现1-100的求和，说出设计思想？
答： 10个线程，size大小为10的int 数组存放每个线程的结果，用countDownLatch控制所有线程计算完毕后，由主线程计算int数组的和。

数据库分开分表的几种方案，用过哪些分库分表中间件？shardingJdbc和Mycat有什么区别？如何对数据库如何进行垂直拆分或水平拆分的？
答：shardingJdbc是sdk的方式耦合在代码里，mycat的mysql的代理服务，对应用无感知。
    垂直拆分是专库专用，把原来的一个大的应用拆分成小服务，每个服务独立一个库。
    水平拆分是把同一个表放到不同的库，解决的是单表数据过大的问题。
zookeeper是如何保证事务的顺序一致性的？
答：zookeeper集群中存在master、slave和observer，master负责事务操作，及所有的写请求都会发送到master，master处理事务请求会放入FIFO
    队列中，这样就保证了顺序一致性。
微服务技术选型：考虑相对全面
JVM垃圾回收过程是怎样的？
redis：
    redis的过期策略都有哪些？LRU代码如何实现？
    如何保证缓存与数据库的双写一致性？
    redis崩溃之后会怎么样？系统该如何应对这种情况？如何处理redis的穿透？
微服务如何拆分？服务边界如何划分？服务是不是拆的越细越好？

如果是分布式系统如如何保证数据的一致性？
数据【1-9】分组，然后根据输入的数据，获取所在的对应的组？
用过哪些分库分表中间件？现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表动态切换到分库分表上？
JVM垃圾回收过程是怎样的？你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms，g1？吞吐量优先和响应优先的垃圾收集器选择？
消息队列相关：
    kafka、rabbitmq、rocketmq都有什么优点和缺点啊?
    如何保证消息队列的高可用啊？
    如何保证消息的顺序性？
    有几百万消息持续积压几小时，说说怎么解决？
redis：
    redis的过期策略都有哪些？LRU代码如何实现？
    如何保证缓存与数据库的双写一致性？
    redis的哨兵原理能介绍一下么？
最近房抵贷系统平台，各租户的数据是如何实现隔离的？
	- 1 物理隔离，根据url，数据参数来路由到不同的db
	- 2 逻辑隔离，根据登陆人的系统参数，过滤不同的数据集
实际项目当中，和第三方直接是如何交互的，数据加密如何实现的？
	webservice 对称，非对称
	http
数据库分开分表的几种方案，用过哪些分库分表中间件？shardingJdbc和Mycat有什么区别？
	
现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表动态切换到分库分表上？
	
如何保证消息的顺序性？rocketmq是如何实现顺序性的
答：同步发送消息，使用MessageQueueSelector一般基于业务号选择发送的队列这样保证了消息被发送到了同一个消息队列
   ，消费者的Listener使用MessageListenerOrderly顺序消费。
	
redis相关
    redis的主从复制原理能介绍一下？
    答：如果是第一次复制，及全量复制，master收到全量请求，发送master runId和offset给从节点
    从节点保存信息，master执行bgsave然后发送rdb文件，在发送过程中产生的数据，复制到repl_back_buffer缓冲区中
    发送缓冲区中数据。
    部分复制，从节点发送自己的offset和runid，master发送从offset到缓冲区队列尾的数据到slave

    redis如何实现的分布式锁？
    答：set if not exist 如果key存在不做任何操作，如果不存在进行set操作
    sentx抢锁后，expire前重启维护了，会怎么样？
    答：永久不能释放锁
    如果redis里有1亿个key，其中10万个key是以某个固定的已知的前缀开头的，怎么将它全部找出来？
    答：使用keys post-loan* 或者 scan 0 match post-loan* count 1000
    如果redis正在给线上提供服务，使用keys指令会有什么问题？
    答：会阻塞后面的请求。



微服务理解， springCloud与dubbo比对，dubbo的协议与超时，分布式事务
答：dubbo协议默认超时时间为1s

mysql索引类型，存储结构， 表锁，行锁
答：普通索引，唯一索引可以有空值，主键索引不能有空值，组合索引基于多个字段的索引
   存储结构为B+Tree
    表锁开销小，加锁快，锁定力度大，并发低
    行锁开销大，加锁慢，力度小，并发高
Srping AOP结合事务管理分析，自调用事务场景分析。
hashMap版本变化分析，扩容死锁

SpringBean的作用域
答：singleton，prototype，request，session，globalSession

dubbo与zk的工作原理。
答：dubbo的provider端的export会在zookeeper上创建一个临时节点，consumer会订阅该节点的信息，
如果客户端发生变化，zookeeper会通知consumer，consumer根据变化更新本地的服务列表。

dubbo的协议与超时，分布式事务，dubbo透传，dubbo filter
答：dubbo框架默认使用dubbo协议，该协议会在服务的基于netty创建服务，默认的超时时间是1s
dubbo的透传及为隐士传参，通过RpcContext设置参数，dubbo的filter是通过ProtocolFilterWapper类创建出来的
filter链，该类是通过dobbu的SPI的自动包装功能实现的，及dubbo的aop功能，所有推展接口的在创建的时候，如果存在
实现了该拓展接口，且构造函数同样是该接口类型的参数存在，就会被视为包装类，进行自动包装。在provider和consumer
执行invoke的时候都会先经过filter链。

JVM内存模型，类加载，类初始化顺序，对象初始化。

隐式类型转换与显示类型转换时的编译时异常与运行时异常
答：类似int 变 long 隐士， long 变 int 显示

RPC调用的阻塞与非阻塞。
答：大部分的RPC的调用都是非阻塞的，都是通过Future的方式来达到阻塞调用的，调用一般都是
请求后把Future放入map中，key为requestId，然后把当前线程阻塞一段时间。
服务的收到请求后处理业务，然后发送请求到客户端，客户端接收请求，获取requestId及客户端上个请求的唯一标识
然后从map获取Future，设置相应结果唤醒客户端阻塞的线程。在指定时间没有结果，则抛出timeoutException，一般
情况下，客户端都会起个定时，处理没有相应的Future。

Mq的选型，项目中的使用场景，延迟消息、事务消息、消息回溯、死信队列、消息积压。

SimpleDateFormat是否线程安全，如何做到线程安全。
答：线程不安全，加锁，局部变量，threadLocal

线程池基础，线程池与跑批调度优先级如何实现。
TreadLocal分析与使用场景。

eureka与zk的对比分析，zk的选举，eureka的服务信息不一致。
api调用保证原子性

String a = "abc"+123;是否异常，创建了几个对象，类型如何转换。
答：一个对象，编译阶段变成了"abc123"


在不同的框架中用到的IO模型，IO模型的了解，AIO,BIO,NIO的对比。

JVM内存模型，类加载，类初始化顺序，对象初始化。


Map类型的变量如何进行深度复制
答：putAll方法

LinkedHashMap和HashMap区别
答：linkedHashMap继承自HashMap，是有序的集合类。支持两种顺序，插入顺序，访问顺序
通过构造函数传入属性accessOrder属性来决定是否是访问顺序，默认是false及插入顺序
通过该属性可以实现lru算法。

ArrayList和linkedlist区别
答：一个基于数组，一个基于链接实现，已至index读取数据Array性能好，中间插入元素linked性能好。

针对于mysql数据库都做过哪些优化？

spring 的aop和ioc，动态代理
答：spring的核心是ioc和aop，aop又是基于ioc的spring实现ioc的方式是依赖注入。
ioc阶段是在对象实例化完成后,后置处理器AutowiredAnnotationBeanPostProcessor，
CommonAnnotationBeanPostProcessor会分别收集带有@Autowired,@value,@Inject,@Resource,@PostConstrct,
@PreDestry注解的信息，创建InjectionMetadata对象beanName为key存入集合。然后执行addSingletonFactory
方法，创建ObjectFactory对象，解决循环依赖问题，这个地方直接返回bean实列而是一个ObjectFactory对象是因为
需要注入的对象可能是代理对象，所以ObjectFactory的getObject会使用到AOP的逻辑。执行InjectionMetadata的
inject方法完成注入。依赖注入发生在bean 的实例化和初始化之间。bean的初始化阶段会设置aware类型属性，然后执行
beanPostProcess的初始化前方法，@PostConstrct标记的方法就是在这个时候被执行的。然后执行实现了initializingBean
接口的bean的afterPropertiesSet方法，调用initMethod。执行beanPostProcess的初始化后方法。

spring的aop是通过beanPostProcessor后置处理器实现的


微服务当中网关如何设计？限流如何实现？
答： API 生命周期管理功能 ，定义，测试，发布，版本管理，热升级，快速回滚。
安全防护，流量控制，请求统一校验，监控报警。无状态应用，优雅下线。动态路由。
例如springcloud gateway 官方提供了基于redish和lua脚本的令牌桶的方式限流，按照一定速率往队列里加入令牌。

spring cloud 组件 hystrix

数据库索引，回表
答：非主键索引需要查询多次成为回表查询。

https相关：一般
全局唯一编号生成
答：数据库自增主键，实现简单。uuid，作为主键性能差。redis自增序列。Twitter开源的算法snowflake等。

业务场景相关：
    多线程下载文件：
    答：基于nio的文件传输，使用channel的transferTo，该方法底层是使用零拷贝技术。



redis 数据结构
答：string，list，zset，set，hash

synchronized锁的升级降级。
答：锁的四种状态，无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态。
   偏向锁，当线程访问代码块并获取锁对象的时候，在对象头中记录偏向锁的threadId，如果没有其它线程获取锁时，锁类型不变，
   如果有其他线程获取，撤销偏向锁，变成轻量级锁，其他线程自旋等待，到达一定次数后，轻量级锁会升级为重量级锁，重量级锁会把所有其他线程都阻塞，防止CPU空转。
   锁只有升级，没有降级。

HashMap的数据结构是怎样的？什么情况下会触发reHash，会有怎样的调整？
答：内部机构是数组+链表+红黑树的结构，在hashMap容量达到阈值的时候，会扩容，这样就触发了reHash。


2、HashTable和ConcurrentHashMap为什么不支持Null？
答：在多线程下不知道是没put进去还是该值就是null。

策略模式有什么优点？适合用什么场景？组合模式用于解决什么问题？
答：策略模式多种算法相似的情况下，用if..else的复杂和难以维护
    组合模式将对象组合成树形结构以表示"部分-整体"的层次结构
构建一个线程池有哪些参数？
答：核心线程数，最大线程数，线程空闲回收时间，时间单位，线程工厂对象，阻塞队列，拒绝策略
CAS的工作原理是怎样的？
答：cas是java里的乐观锁，对比交换，本地方法，操作系统支持,一般配合volatile修饰的属性，例如Atomic类型的原子操作。
ThreadLocal是怎样保存数据线程安全的？
答：每个线程复制一个副本。线程访问的都是自己的副本对象，没有共享资源，从而不会有线程安全问题
java垃圾回收是如何判定一个对象是可回收的？新生代和老年代的回收算法是怎样的？
答：基于可达性分析算法，从GCRoot对象作为起点，如果一个对象到GCRoot没有引用链，视为不可达，该对象就是可回收对象
    GCRoot 栈中引用的对象，方法区静态属性、常量引用的对象，本地方法栈中JNI引用的对象
    新生代使用复制算法，在新生代分为eden区，两个survivor区，将存活的对象从eden和survivor其中一个区域复制到一个空的survivor区域
    老年代使用标记整理算法。
Spring不能解决什么场景下的循环依赖？是如何怎样解决循环依赖的问题的？
答：不能解决基于构造方法场景下的依赖注入，例如在创建对象的时候发现有其他依赖对象。
    如果是属性注入，方法注入是可以的，在对象实例化后，spring会创建ObjectFactory对象，该对象存有实例化对象的引用。属性的注入是在对象初始化之前的。
    只要完成了对象的实例化，即可注入到依赖对象中。可后续完成初始化。创建ObjectFactory是因为依赖的对象可能是代理对象不是当前实例化的对象，及ObjectFactory会
    会触发AOP相关的功能。
Mysql InnoDB的索引结构是怎样的？什么是回表？
答：mysql索引结构是B+Tree
    回表是要两次从B+索引中取数据
    例如：基于主键查询所有列，这样就不会产生回表，因为在主键的索引树中能找到所有记录
          如果是基于唯一索引去查询所有列，那么除主键和索引列外的值索引树是不能找到的，然后需要从主键的索引树获取其他字段值。这样就产生了回表。
Mysql是如何实现主从同步的？InnoDB为什么需要一个binLog和一个redoLog来保证事务？
答： master slave建立链接，master 获取slave传送的index 和master的binlog的index比较，如果一致
就等待binlog的变化，如果不一致就把slave的index到binlog索引之间的数据发送给slave。slave把数据写入
relay文件中，记录当前写入的index，slave另一个线程会监测relay的变化，如果有改动就把变动内容转换为sql语句
执行到数据库中。
    binLog是mysql层面的，不论你的存储引擎是什么都需要binLog， 而redoLog 是InnoDB的保证事务的。

可重复读解决了幻读问题吗？解决了什么场景下的幻读？
答：mysql的可重复读没有决绝幻读问题，只是解决了读数据的幻读问题。

redis有哪些方式可以解决缓存穿透问题？
答：DB中没有的数据，也基于key存储到redis，避免暴力攻击。
用过哪些java的锁？JVM会怎样进行锁升级？什么是自旋锁？
答：ReentrantLock,synchronized，当一个线程获取对象锁的时候，默认是偏向锁，如果没释放锁之前，又有一个线程来竞争锁，那么进行锁升级
    偏向锁，变成自旋锁，及cas的方式获取锁，比较耗CPU，如果自旋一定次数后，依旧没有获取到锁，则升级锁，变成重量级锁，重量级锁会把其他线程阻塞
了解AQS吗？ReentrantLock是如何使用AQS对象的高低位的？分别用于存储什么？
17、ReadWriteLock是如何利用AQS的高低位的？分别用于存储什么？